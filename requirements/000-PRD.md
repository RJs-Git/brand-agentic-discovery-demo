# AI-Agent Travel PoC Demo Design: *“New Inventory to Agentic Booking”*

**Overview:** This proof-of-concept demonstrates how a travel brand can **rapidly surface new offerings** (e.g. a hotel *Kids’ Club* amenity or an airline *Ride App Pickup* service) to AI-powered agents and end-users. It covers the end-to-end flow: from an employee adding a new product feature, through backend knowledge graph and intent catalog updates, to an AI agent (Claude Desktop) retrieving the new option and completing a booking via the Agentic Commerce Protocol (ACP). By simulating both hotel and airline scenarios with *mock data*, the PoC showcases **tangible business value** (e.g. improved “family travel” offerings and seamless door-to-door journey options) without relying on any private data sources. Key AWS components (Neptune, AppSync, Step Functions, Lambda, Bedrock, etc.) are used to keep the solution **cloud-native and easy to implement** for an AWS-proficient engineer.

<img width="1879" height="2268" alt="image" src="https://github.com/user-attachments/assets/3c4f9362-b631-4229-8bb9-e4f0d4c2911b" />


***

## 1. New Inventory Addition (Hotel & Airline scenarios)

**PoC Action:** Simulate an internal tool or API call where an employee adds a new inventory type to the travel product catalog for each scenario:

*   *Hotel scenario:* Add a **“Kids’ Club”** amenity under a specific hotel property (e.g. *Sunshine Resort, Hawaii*).
*   *Airline scenario:* Add a **“Ride App Pickup”** service option under a flight class or route (e.g. *Premium Economy class for JFK–LAX route*).

**Implementation:** A lightweight front-end or script (could be as simple as a CLI or a minimal web form) invokes an **AWS AppSync GraphQL** mutation to insert the new inventory item into the **Amazon Neptune** knowledge graph. The Neptune graph stores the travel “digital twin” – all products, properties, routes, and their attributes (rooms, amenities, policies, add-ons, etc.). Using GraphQL via AppSync ensures the data is added in a structured, schema-valid way with minimal boilerplate. Meanwhile, **AWS Glue Data Catalog** can store metadata (if needed, for discovery or schema evolution) but isn’t heavily used in the PoC. , 

<insight>By modeling product data as a graph, the new offering becomes immediately *machine-visible* and queryable by downstream systems. This lays the foundation for AI agents to “see” the brand’s latest features (e.g. an amenity signaling *family-friendliness* or a service enhancing *ground transport*).</insight> 

**Mock Data Approach:** Use a **synthetic dataset** of a few hotels and flight routes. For example, pre-load Neptune with a small set of nodes/edges:

*   Hotel nodes with properties (“OceanView Resort”, location, existing amenities like pool, Wi-Fi, etc.).
*   Airline route nodes (“NYC to LA”, classes, existing services like in-flight meal).

Then the mutation adds:

```graphql
# Pseudo-GraphQL mutation for Neptune via AppSync
mutation {
  addInventory(type: "Amenity", name: "Kids' Club", propertyId: "hotel123") {
     id, name, property { name }
  }
}
```

*(Similarly for airline: `addInventory(type: "Service", name: "Ride App Pickup", routeId: "route789")`.)*

This triggers an **Amazon EventBridge event** (e.g. `InventoryAdded`) carrying details of the new inventory item and context (hotel or route ID), which is picked up by the next step.

***

## 2. Knowledge Graph & Data Update

Once the new node is in Neptune, the **Product & Content Graph** now includes the fresh inventory type linked to the respective product. This graph update is critical for later retrieval:

*   The Neptune graph might represent that *Hotel Sunshine Resort* now has an amenity node *KidsClub*, perhaps with attributes like age range, hours, etc.
*   Or that *Flight JFK–LAX PremiumEconomy* now has a service node *RideAppPickup* with details on the rideshare partner or pickup process.

The PoC can include a **GraphQL query** to verify this update (ensuring our mock data is consistent). For instance:

```graphql
query {
  getProperty(id: "hotel123") {
    name, amenities { name, type }
  }
}
```

should now list “Kids’ Club” as an amenity of *Sunshine Resort*. This step confirms that our digital twin (knowledge graph) is successfully updated in **real-time**. In a real system, this means any downstream consumer of the graph (search indexes, recommendation engines, etc.) now has the new info.

*Why Neptune & GraphQL:* Using Neptune (a fully managed graph DB) and AppSync **makes it easy for an engineer to stand up a graph-backed catalog**. There’s no heavy custom backend needed – AppSync auto-generates resolvers to Neptune, and you can manage data with simple GraphQL calls. This aligns with the solution principle of having a centralized, structured knowledge base. 

No private data is needed – we only use **dummy travel products**. (E.g., the PoC might define a fictional hotel and flight route in Neptune with a minimal schema, just enough to demonstrate linking new offerings.)

***

## 3. Intent Analysis & Catalog Update (Rules Engine)

**Goal:** When a new inventory type is added, the system should assess how it maps to traveler *intents* or needs. This ensures that if customers search via an AI agent for those intents, the new product will surface.

**Mechanism:** The previously emitted `InventoryAdded` event (via EventBridge) triggers a **AWS Step Functions** workflow (or a direct Lambda) as part of an **Intent & Rules Engine**. This workflow: 

1.  **Classifies the new inventory type** – e.g., recognizes “Kids’ Club” as related to *family/kid-friendly travel*, and “Ride App Pickup” as related to *convenience/ground-transport*. This can be a simple rules-based mapping or a machine learning lookup in a **Lambda** function (for PoC, a hard-coded dictionary of keywords to intent tags is sufficient). For example:
    *   `"Kids' Club"` → intent category **FamilyVacation** (indicates amenities for children, aligns with a *“family vacation”* intent). 
    *   `"Ride App Pickup"` → intent category **SeamlessJourney** or **DoorToDoor** (aligns with intent of *“smooth ground transportation”* or *business traveler convenience*).

2.  **Updates the Intent Catalog** – writes an entry linking the new inventory type or the associated product to the identified intent(s). The intent catalog could be a simple table or another small graph. For PoC ease, we might use an **Amazon DynamoDB** table or even a JSON file in S3 to record: e.g., `{ intent: "FamilyVacation", adds: ["Kids' Club at Sunshine Resort"] }`. If using DynamoDB, the Lambda can upsert an item with key = "FamilyVacation" and add the hotel’s ID to a list of products fulfilling that intent.

3.  Optionally, **adjust eligibility rules or bundles**: If the brand has predefined product bundles or booking rules that relate to the new feature (e.g., a “Family Fun Package” that should now include properties with Kids’ Clubs), the Step Function could trigger updates to those definitions as well. This might involve another Lambda updating a config file or Step Functions orchestrating a check – for simplicity, the PoC can log that “Bundle X updated to include the new amenity” without a full implementation.

**Mock Data:** Prepare a small **Intent Catalog** of a few intents to simulate mapping:

*   *FamilyVacation:* expecting amenities like connecting rooms, kids’ meals, **Kids’ Club**, etc.. 
*   *BusinessTrip:* expecting services like airport lounge, **Ride App Pickup**, etc.
*   *(Any other relevant intents, e.g. “EcoTravel” to show extensibility.)*

The new inventory triggers adding our hotel or flight into these lists. For example, after adding “Kids’ Club”, the intent “FamilyVacation” now includes *Sunshine Resort* as a matching option. This way, when an agent later searches for *family-friendly* travel, our updated catalog will ensure Sunshine Resort is considered.

Using Step Functions + Lambda makes the flow **easy to develop and modify**. A skilled AWS engineer can implement the rules in Lambda code (in Python/Node.js) and orchestrate more complex logic via the visual Step Functions editor. **Amazon EventBridge** neatly decouples the trigger from the processing (new inventory events could fan out to other subsystems too, if needed), following good event-driven design.

***

## 4. Customer Search via Claude (AI Agent Frontend)

With the backend updated, a customer can now find the new offering through an AI assistant. This PoC assumes the user interacts with **Claude Desktop**, which is a conversational agent interface. The key is enabling Claude (or any AI front-end) to query our system:

*   We implement an **Agent-facing “Answers” API** (sometimes called an **MCP – Master Control Program** or *Answers Microservice*) that Claude can call. This API serves as the gateway to our travel brand’s data for the agent. It can be a REST endpoint (via **Amazon API Gateway**) which accepts search requests (e.g. `GET /search?intent=family` or a richer JSON query). 
*   **Integration Option 1: Claude Skill.** We create a Claude Skill (a plugin/extension for the Claude AI) that knows how to call this API when relevant. For instance, when the user asks “Find me a family-friendly hotel in Hawaii,” Claude’s skill triggers a call to our `/searchHotels?intent=FamilyVacation&location=Hawaii` endpoint.
*   **Integration Option 2: Direct API (MCP).** If the AI front-end platform supports direct tool use (like OpenAI function calling or similar agent tool use), Claude could call the API directly based on the conversation (similar to how ChatGPT plugins work). The “MCP” in this context is essentially our **Answers service** that any agent or frontend (voice assistant, web app, chatbot, etc.) can query to get structured answers about products. 

**Query Handling:** The Answers API will:

*   **Interpret the user query**: e.g., map natural language to an intent and filters. (Claude’s LLM can do some of this understanding, or the API can do a simple lookup. For PoC, we might let Claude include an intent tag in the API call via the skill configuration.)

*   **Retrieve matching options**: Use the **Knowledge Graph** and **Intent Catalog** to find products that match the query. For example, if the query implies `intent=FamilyVacation` and `destination=Hawaii`, the service will query Neptune (via AppSync or a direct Gremlin/SPARQL query) for hotels in Hawaii that have amenities linked to *FamilyVacation*. Thanks to Step 2–3, *Sunshine Resort* (with its new Kids’ Club) is now linked to that intent, so it will be fetched. For the airline query, if the user asked for ease of ground transport, the intent might be recognized as `SeamlessJourney` and the service would look up flights or routes that have `Ride App Pickup` in that route (e.g., our JFK–LAX flight).

*   **Fetch real-time data**: The service also calls **Real-time Price & Availability APIs** to get up-to-date rates or availability for those options. In our PoC, this can be a mock call to an **Amazon Aurora** (MySQL/PostgreSQL) database or an **ElastiCache (Redis)** entry where we’ve stored sample pricing. For simplicity, we might seed an Aurora table with the price of a night at Sunshine Resort and a price for the Premium Economy ticket, and query it here. (These services illustrate how in a production system the API ensures facts like price and room availability are fresh when responding to the agent’s query.) 

*   **Compose a response**: Return a structured list of options (e.g. in JSON) to Claude. For example:
    ```json
    {
      "intent": "FamilyVacation",
      "results": [
         { "type": "hotel", "name": "Sunshine Resort", "location": "Hawaii", 
           "features": ["Kids' Club", "Pool", "Free WiFi"],
           "price_per_night": "$250", "availability": "Dec 1-7: Available" },
         ... possibly other hotels ...
      ]
    }
    ```
    And similarly for an airline search:
    ```json
    {
      "intent": "SeamlessJourney",
      "results": [
         { "type": "flight", "route": "JFK-LAX", "class": "PremiumEconomy",
           "features": ["Ride App Pickup", "Lounge Access"],
           "price": "$450", "next_flight": "2025-12-15 08:00", "seats_left": 5 }
      ]
    }
    ```
    This response highlights the new inventory items in **bold** or as special icons in the front-end UI (for demo storytelling, one could emphasize “Kids’ Club” in the hotel description).

**Mock Data Consideration:** Since we use only synthetic data, the Answers API can be implemented with simple logic:

*   For hotel queries, ignore actual NLP parsing and assume “family” maps directly to our `FamilyVacation` intent (or use a fixed mapping in the Claude skill prompt).
*   Then just return the one hotel (Sunshine Resort) that we know matches. We can still show the mechanism of going through Neptune: e.g., perform a Neptune query for any hotel node with an amenity labeled “Kids’ Club” in Hawaii.
*   For flights, do similarly for the one flight with “Ride App Pickup”.

**Ease of Development:** All components here use managed AWS services:

*   AppSync for querying Neptune (GraphQL can directly fetch the graph data by intent or property).
*   Aurora Serverless for a quick spin-up of a SQL table for prices, or even using **Amazon DynamoDB** for price if we prefer NoSQL (since it’s just a key-value of product ID to price).
*   Lambda for any glue logic (though a simple search might be done in a single Lambda that queries both Neptune and Aurora).
*   API Gateway to expose the Lambda or Step Function as a RESTful endpoint to the outside world (Claude).
*   If using **Amazon Bedrock** (for Retrieval-Augmented Generation or Q\&A), one could integrate a Bedrock-hosted model if the queries were more free-form. For example, if a user asked a complex question (“Which Hawaii resorts have something fun for kids under 5?”), our Answers API **could** vector-search a knowledge base of resort descriptions for “kids” and “under 5” using a Bedrock RAG approach. However, for this PoC use-case, a structured approach is sufficient and easier, so Bedrock is optional.

***

## 5. Presenting Results to the User (Claude Desktop)

On the front-end side, Claude receives the response and displays the travel options to the user. In our PoC demo narrative:

*   If the user query was for a hotel, Claude might say: *“I found a family-friendly hotel: Sunshine Resort in Hawaii (with a **Kids’ Club** for children). It’s available for your dates at $250/night.”*
*   If the query was for a flight or part of a multi-modal trip, Claude might respond: *“I found a flight that fits your request: a Premium Economy ticket from JFK to LAX that includes **Ride App Pickup** service at your destination.”*

The new inventory types are clearly reflected in the answer, proving that the system “understood” and utilized the additions. This directly demonstrates **business value**: the brand’s unique selling points (family amenity, seamless transit) are **made legible to the AI agent and presented to the customer** – leading to higher chances of selection. In a real scenario, this could translate to increased bookings for the hotel or airline because they are now being recommended for relevant customer intents (improving the brand’s *“share of agent shortlists”* KPI). 

For the demo, the Claude interface can be simulated if needed (since we can’t use private data, we won’t integrate an actual proprietary Claude instance). Options:

*   Use a **mock chatbot UI** that takes a query and internally calls the Answers API, then prints a friendly response (essentially mimicking Claude’s behavior).
*   Or demonstrate via the API’s returned JSON in the console, explaining “This is what Claude would present.”

**Claude Skill vs MCP:** We ensure the design supports multiple frontends:

*   If using a **Claude Skill**, it could also be reused in a mobile app or another agent like Alexa (with some adaptation), thus showing multi-channel capability.
*   The **Answers MCP API** approach inherently allows any client (web, mobile, voice agent) to get consistent results by hitting the same backend. This aligns with making the solution **frontend-agnostic** and easy to plug into new interfaces (a selling point for business value: “build once, use anywhere”).

***

## 6. Booking via Agentic Commerce Protocol (ACP)

When the user decides on an option, the final step is executing the booking through the agent. The **Agentic Commerce Protocol (ACP)** is an emerging open standard (from OpenAI & Stripe) for AI agents to perform transactions on behalf of users. In our PoC, we won’t connect to actual payment systems, but we will illustrate how it would work:

*   The Answers API or a related **Booking service** would prepare an **ACP offer** for the selected product. This typically means providing structured data like product ID, price, and a URL or API for the agent to confirm booking and make payment.
*   For instance, if the user says “Yes, book this hotel,” Claude (following ACP specs) would send a purchase request. We simulate this by having a **dedicated API endpoint** (maybe `/book`) that the agent calls with the chosen option’s ID.
*   That `/book` endpoint (backed by a Lambda in our PoC) will perform a fake booking: e.g., log the booking, and respond with a confirmation object. If we wanted to be closer to reality, this is where one would integrate with a payment sandbox (like Stripe test environment) to simulate payment authorization, or simply return a success message.

**No Private Data & Mock:** Because we avoid private data, no actual user payment info is used. We can have the Lambda auto-confirm the booking. The demo can show a confirmation message in Claude: *“Great, I’ve booked Sunshine Resort for you. Confirmation #ABC123. Enjoy your stay!”* – indicating the ACP flow completed.

Technically, to implement ACP in the PoC minimally, we can follow the open specification to structure the interaction (for example, ACP uses a series of messages: offer, acceptance, payment, etc. – but for simplicity, our single API call demo stands in for these steps). The key takeaway to highlight is that **our platform is ready for agent-driven commerce**, meaning it can handle end-to-end transactions without the user ever leaving the agent interface. This is a forward-looking capability that adds business value by reducing friction in the purchase process.

***

## 7. **Architecture Summary & Components**

The table below summarizes the PoC components, the AWS services utilized for each, and how we use **mock data** to keep it self-contained and privacy-safe:

| **PoC Component & Step**                                                                                      | **Key AWS Services**                                                                                                                                                                                                                                                                                                                                                                                                      | **Mock Data Strategy (No Private Data)**                                                                                                                                                                                                                                                                                                                                                                                                   |
| ------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **1. Inventory Addition Interface**<br>*Employee adds new product feature (hotel amenity or flight service).* | – **AppSync (GraphQL API)** to Neptune<br>– Amazon **Neptune** (Graph DB) for product catalog<br>– AWS **Glue Data Catalog** (schema/metadata)                                                                                                                                                                                                                                                                            | **Synthetic travel data**: e.g. a fictional hotel “Sunshine Resort” and a flight route “JFK–LAX”. New entries “Kids’ Club” and “Ride App Pickup” are added with dummy details (opening hours, partner name, etc.).                                                                                                                                                                                                                         |
| **2. Knowledge Graph Update**<br>*Digital twin updated with new node/edge.*                                   | – **Neptune** (graph update commit)<br>– **AppSync** (query to verify/notify)<br>– *Trigger:* **EventBridge** event (“InventoryAdded”)                                                                                                                                                                                                                                                                                    | **Pre-seeded graph**: a small set of hotel/flight nodes and edges created in advance (e.g. locations, existing amenities). The new inventory is added to this toy dataset.                                                                                                                                                                                                                                                                 |
| **3. Intent Catalog & Rules Engine**<br>*Map new inventory to user intent.*                                   | – **Amazon EventBridge** (event-driven trigger)<br>– **AWS Step Functions** (or Lambda chain) for orchestration<br>– **AWS Lambda** (custom mapping logic code)<br>– **DynamoDB** or Amazon **S3** (store intent→product mapping)                                                                                                                                                                                         | **Dummy intent list**: Define a few intent categories (“FamilyVacation”, “SeamlessJourney”, etc.) and store them in DynamoDB or a JSON file. The Lambda function has a simple dictionary to map keywords (e.g. “kids” → FamilyVacation). It updates the store with links to the new product IDs. No real user data needed.                                                                                                                 |
| **4. Agent-Facing Answers API (MCP)**<br>*Search interface for agents (Claude skill or API).*                 | – **Amazon API Gateway** (expose a RESTful endpoint)<br>– **AWS Lambda** (to handle search requests, coordinate DB calls)<br>– **Amazon Neptune** (graph query for products by intent/filters)<br>– **AppSync** (could also be used here to simplify Neptune queries)<br>– **Amazon Aurora** (MySQL/Postgres) **or DynamoDB** for pricing/availability data<br>– *(Optional:* **Amazon Bedrock** RAG for advanced Q\&A)\* | **Query logic stub**: Rather than full NLP, assume structured queries. Prepare **fake pricing data** in Aurora or Dynamo (e.g., price $250 for hotel, $450 for flight). Availability can be a hardcoded value (e.g., “5 rooms open”). The Lambda simply looks up in Neptune by intent (which is easy since we know the product was tagged to “FamilyVacation” or such) and fetches the price from the DB. It returns a synthesized result. |
| **5. Claude Frontend Integration**<br>*Claude Desktop uses skill or direct API to get results.*               | – *(Not an AWS service, this is agent integration)*<br>– **Claude Skill** (custom integration code) *or* simply configuring Claude with the API endpoint and JSON parsing instructions.                                                                                                                                                                                                                                   | **Simulation**: We can simulate Claude’s query by calling the API ourselves. No actual user data – we might construct a sample JSON query as if from Claude. The focus is showing the response format with the new feature included. For demo, we may script a **fake Claude dialogue** illustrating the bot’s question and answer.                                                                                                        |
| **6. User Sees New Options**<br>*Results displayed with new inventory highlight.*                             | – **(front-end/UI component)** e.g. a simple web page or console log for demo<br>– **Amazon QuickSight** (optional, if demonstrating a simple dashboard for results or for KPI tracking)                                                                                                                                                                                                                                  | **Output rendering**: We’ll create a predefined output in the demo to show the hotel and flight found. Since this is static text for PoC, no sensitive info. (If using QuickSight or any UI, populate it with our dummy option data.)                                                                                                                                                                                                      |
| **7. Booking via ACP**<br>*Agent completes purchase transaction.*                                             | – **AWS Lambda** (to handle booking request, e.g. process payment or confirmation logic)<br>– **Stripe API** or **ACP SDK** (for a real payment integration – optional; PoC can mock this)<br>– **Amazon API Gateway** (expose booking endpoint to agent)                                                                                                                                                                 | **Fake booking**: The Lambda doesn’t charge money; it simply generates a confirmation ID (random string). We avoid real credit cards by either not integrating Stripe at all or using Stripe’s test mode with a dummy API key if demonstration of that standard is desired. The confirmation details use dummy PNR/booking IDs.                                                                                                            |

*Note:* Additional peripheral components from the solution overview are present but simplified in the PoC:

*   **Trust & Telemetry Pipeline:** We suggest streaming events (like “inventory added”, “intent searched”, “booking completed”) into Amazon **Kinesis Data Streams** and logging metrics in **Amazon Timestream** (e.g., how quickly after adding a Kids’ Club did it appear in a search result). For brevity, the PoC may omit a full telemetry implementation, but one can stub this by printing logs or sending a couple of events to CloudWatch. In real use, these provide ops insights and feed **QuickSight dashboards** for “Agent SEO” KPIs. 
*   **Consent & Clean Rooms:** Not directly used in this single-brand demo, since we aren’t sharing data with partners here. We simply note that all demo data is synthetic, and no user PII is involved. In a true multi-partner scenario, AWS Clean Rooms and Lake Formation would ensure any joint datasets (e.g. hotel + airline bundle analysis) remain anonymized and controlled.
*   **Observability & Monitoring:** The PoC will use **CloudWatch Logs** (from our Lambdas and Step Functions) and could include some CloudWatch Alarms or X-Ray traces to show performance. This emphasizes that our solution is production-grade, with monitoring of latency (ensuring the agent’s questions are answered quickly, a critical factor for AI UX).

***

## 8. Emphasizing Real Business Value

This PoC focuses on *business value outputs* at each stage, not just technical wiring:

*   **Speed to Market:** A new amenity or service, once added in the system, is immediately discoverable by AI agents. This means businesses can rapidly merchandise new features. For example, a hotel’s addition of a Kids’ Club is useless unless family travelers know about it – this system ensures AI trip planners know, bridging that gap virtually in real-time.
*   **Intent-Based Upsell:** By mapping the new inventory to a traveler intent, the brand gets slotted into relevant recommendations. Our demo explicitly ties “Kids’ Club” to the *Family Vacation* intent, so the hotel can compete for that segment’s bookings. Likewise, the airline’s ride-hail pickup appeals to *convenience-focused* travelers (business or leisure), giving the airline a competitive edge in those trip plans. This shows how **revenue can increase by aligning products to intents** (the agent won’t miss your unique offering). , 
*   **Omnichannel AI readiness:** Leveraging **Claude Skills and an open API (MCP)** means the solution is not limited to one channel – the same backend could feed results to voice assistants, chatbots, or other AI platforms. The demo can highlight this by mentioning multiple frontend possibilities (even if we only simulate Claude, we’d note that Alexa or a web chatbot could call the same API). This investment protects the brand as consumers adopt various AI assistants.
*   **Demonstrated ACP Integration:** By incorporating the Agentic Commerce Protocol, the PoC addresses the *last mile* of the user journey – actual booking. This is a significant business value: eliminating friction in conversion. If an AI can take the user from query to confirmed purchase in one flow, drop-off rates shrink and whoever provides the best integrated experience gains the sale. Our design aligns with the latest industry standard for agent-driven commerce, showcasing that the brand is ready for the emerging ecosystem of autonomous shopping.
*   **Ease of Build & Extensibility:** All chosen AWS components are fully managed or serverless, reducing the operational burden. A single dev can deploy Neptune, AppSync, Step Functions, etc., in a short time, and easily extend the schema or rules. For instance, adding another intent mapping or another inventory type (say “EV charger availability” for car rentals) would just be another entry in the rules logic and graph, following the same pattern. This agility is a selling point to stakeholders – the architecture can evolve with business needs (**add new intents, products, partners** without a complete overhaul).

Finally, the PoC can be wrapped up with a **demo narrative**: *“Watch as our travel brand’s system instantly integrates a new Kids’ Club amenity: an employee adds it, the backend graph and rules light up, and moments later an AI agent recommends that hotel to a family planning a trip – who then seamlessly books it in-session.”* This narrative underscores **real-world value: faster innovation uptake, better AI visibility, and frictionless conversion**, all achieved with a lean, cloud-native solution.
